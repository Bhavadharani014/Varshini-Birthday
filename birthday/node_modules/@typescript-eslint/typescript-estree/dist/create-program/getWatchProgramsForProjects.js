"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.getWatchProgramsForProjects = exports.clearWatchCaches = void 0;
const debug_1 = __importDefault(require("debug"));
const fs_1 = __importDefault(require("fs"));
const semver_1 = __importDefault(require("semver"));
const ts = __importStar(require("typescript"));
const shared_1 = require("./shared");
const log = (0, debug_1.default)('typescript-eslint:typescript-estree:createWatchProgram');
/**
 * Maps tsconfig paths to their corresponding file contents and resulting watches
 */
const knownWatchProgramMap = new Map();
/**
 * Maps file/folder paths to their set of corresponding watch callbacks
 * There may be more than one per file/folder if a file/folder is shared between projects
 */
const fileWatchCallbackTrackingMap = new Map();
const folderWatchCallbackTrackingMap = new Map();
/**
 * Stores the list of known files for each program
 */
const programFileListCache = new Map();
/**
 * Caches the last modified time of the tsconfig files
 */
const tsconfigLastModifiedTimestampCache = new Map();
const parsedFilesSeenHash = new Map();
/**
 * Clear all of the parser caches.
 * This should only be used in testing to ensure the parser is clean between tests.
 */
function clearWatchCaches() {
    knownWatchProgramMap.clear();
    fileWatchCallbackTrackingMap.clear();
    folderWatchCallbackTrackingMap.clear();
    parsedFilesSeenHash.clear();
    programFileListCache.clear();
    tsconfigLastModifiedTimestampCache.clear();
}
exports.clearWatchCaches = clearWatchCaches;
function saveWatchCallback(trackingMap) {
    return (fileName, callback) => {
        const normalizedFileName = (0, shared_1.getCanonicalFileName)(fileName);
        const watchers = (() => {
            let watchers = trackingMap.get(normalizedFileName);
            if (!watchers) {
                watchers = new Set();
                trackingMap.set(normalizedFileName, watchers);
            }
            return watchers;
        })();
        watchers.add(callback);
        return {
            close: () => {
                watchers.delete(callback);
            },
        };
    };
}
/**
 * Holds information about the file currently being linted
 */
const currentLintOperationState = {
    code: '',
    filePath: '',
};
/**
 * Appropriately report issues found when reading a config file
 * @param diagnostic The diagnostic raised when creating a program
 */
function diagnosticReporter(diagnostic) {
    throw new Error(ts.flattenDiagnosticMessageText(diagnostic.messageText, ts.sys.newLine));
}
function updateCachedFileList(tsconfigPath, program, parseSettings) {
    const fileList = parseSettings.EXPERIMENTAL_useSourceOfProjectReferenceRedirect
        ? new Set(program.getSourceFiles().map(sf => (0, shared_1.getCanonicalFileName)(sf.fileName)))
        : new Set(program.getRootFileNames().map(f => (0, shared_1.getCanonicalFileName)(f)));
    programFileListCache.set(tsconfigPath, fileList);
    return fileList;
}
/**
 * Calculate project environments using options provided by consumer and paths from config
 * @param parseSettings Internal settings for parsing the file
 * @returns The programs corresponding to the supplied tsconfig paths
 */
function getWatchProgramsForProjects(parseSettings) {
    const filePath = (0, shared_1.getCanonicalFileName)(parseSettings.filePath);
    const results = [];
    // preserve reference to code and file being linted
    currentLintOperationState.code = parseSettings.code;
    currentLintOperationState.filePath = filePath;
    // Update file version if necessary
    const fileWatchCallbacks = fileWatchCallbackTrackingMap.get(filePath);
    const codeHash = (0, shared_1.createHash)(parseSettings.code);
    if (parsedFilesSeenHash.get(filePath) !== codeHash &&
        fileWatchCallbacks &&
        fileWatchCallbacks.size > 0) {
        fileWatchCallbacks.forEach(cb => cb(filePath, ts.FileWatcherEventKind.Changed));
    }
    const currentProjectsFromSettings = new Set(parseSettings.projects);
    /*
     * before we go into the process of attempting to find and update every program
     * see if we know of a program that contains this file
     */
    for (const [tsconfigPath, existingWatch] of knownWatchProgramMap.entries()) {
        if (!currentProjectsFromSettings.has(tsconfigPath)) {
            // the current parser run doesn't specify this tsconfig in parserOptions.project
            // so we don't want to consider it for caching purposes.
            //
            // if we did consider it we might return a program for a project
            // that wasn't specified in the current parser run (which is obv bad!).
            continue;
        }
        let fileList = programFileListCache.get(tsconfigPath);
        let updatedProgram = null;
        if (!fileList) {
            updatedProgram = existingWatch.getProgram().getProgram();
            fileList = updateCachedFileList(tsconfigPath, updatedProgram, parseSettings);
        }
        if (fileList.has(filePath)) {
            log('Found existing program for file. %s', filePath);
            updatedProgram =
                updatedProgram !== null && updatedProgram !== void 0 ? updatedProgram : existingWatch.getProgram().getProgram();
            // sets parent pointers in source files
            updatedProgram.getTypeChecker();
            return [updatedProgram];
        }
    }
    log('File did not belong to any existing programs, moving to create/update. %s', filePath);
    /*
     * We don't know of a program that contains the file, this means that either:
     * - the required program hasn't been created yet, or
     * - the file is new/renamed, and the program hasn't been updated.
     */
    for (const tsconfigPath of parseSettings.projects) {
        const existingWatch = knownWatchProgramMap.get(tsconfigPath);
        if (existingWatch) {
            const updatedProgram = maybeInvalidateProgram(existingWatch, filePath, tsconfigPath);
            if (!updatedProgram) {
                continue;
            }
            // sets parent pointers in source files
            updatedProgram.getTypeChecker();
            // cache and check the file list
            const fileList = updateCachedFileList(tsconfigPath, updatedProgram, parseSettings);
            if (fileList.has(filePath)) {
                log('Found updated program for file. %s', filePath);
                // we can return early because we know this program contains the file
                return [updatedProgram];
            }
            results.push(updatedProgram);
            continue;
        }
        const programWatch = createWatchProgram(tsconfigPath, parseSettings);
        knownWatchProgramMap.set(tsconfigPath, programWatch);
        const program = programWatch.getProgram().getProgram();
        // sets parent pointers in source files
        program.getTypeChecker();
        // cache and check the file list
        const fileList = updateCachedFileList(tsconfigPath, program, parseSettings);
        if (fileList.has(filePath)) {
            log('Found program for file. %s', filePath);
            // we can return early because we know this program contains the file
            return [program];
        }
        results.push(program);
    }
    return results;
}
exports.getWatchProgramsForProjects = getWatchProgramsForProjects;
const isRunningNoTimeoutFix = semver_1.default.satisfies(ts.version, '>=3.9.0-beta', {
    includePrerelease: true,
});
function createWatchProgram(tsconfigPath, parseSettings) {
    log('Creating watch program for %s.', tsconfigPath);
    // create compiler host
    const watchCompilerHost = ts.createWatchCompilerHost(tsconfigPath, (0, shared_1.createDefaultCompilerOptionsFromExtra)(parseSettings), ts.sys, ts.createAbstractBuilder, diagnosticReporter, 
    /*reportWatchStatus*/ () => { });
    if (parseSettings.moduleResolver) {
        // eslint-disable-next-line deprecation/deprecation -- intentional for older TS versions
        watchCompilerHost.resolveModuleNames = (0, shared_1.getModuleResolver)(parseSettings.moduleResolver).resolveModuleNames;
    }
    // ensure readFile reads the code being linted instead of the copy on disk
    const oldReadFile = watchCompilerHost.readFile;
    watchCompilerHost.readFile = (filePathIn, encoding) => {
        const filePath = (0, shared_1.getCanonicalFileName)(filePathIn);
        const fileContent = filePath === currentLintOperationState.filePath
            ? currentLintOperationState.code
            : oldReadFile(filePath, encoding);
        if (fileContent !== undefined) {
            parsedFilesSeenHash.set(filePath, (0, shared_1.createHash)(fileContent));
        }
        return fileContent;
    };
    // ensure process reports error on failure instead of exiting process immediately
    watchCompilerHost.onUnRecoverableConfigFileDiagnostic = diagnosticReporter;
    // ensure process doesn't emit programs
    watchCompilerHost.afterProgramCreate = (program) => {
        // report error if there are an